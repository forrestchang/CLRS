#+TITLE: CLRS Notes

* 第二部分 排序和顺序统计学
** 第6章 堆排序
- 像合并排序而不像插入排序，堆排序的运行时间为O(nlgn)；
- 像插入排序而不像合并排序，它是一种原地（in place）排序算法：在任何时候，数组中只有常数个元素存储在输入数组以外。

堆排序结合了插入排序和合并排序的优点。

*** 堆
- 二叉树与位置树

  二叉树的定义是以递归的形式给出的。
  
  不包含任何节点的二叉树称为空树或者零树。如果左子树非空，则它的根称为整棵树的左子女，如果一个子树是空树，则称子女缺失或丢失。


表示堆的数组A是一个具有两个属性的对象：length[A]是数组中元素的个数，heap-size[A]是存放在A中的堆的元素的个数。树的跟为A[1]，给定了某个节点的下标i：
- Parent(i) return ⎣i/2⎦
- Left(i) return 2i
- Right(i) return 2i+1

二叉堆有两种：最大堆和最小堆（小根堆）。
- 最大堆的特性：
  除了根以外的每个节点i，有A[Parent(i)] <= A[i]，即某个节点的值至多和其父节点的值一样大。这样，堆中的最大元素就存放在根节点中；并且，在以某一个节点为根的子树中，各节点的值都不大于该子树根节点的值。
- 最小堆的特性：
  与最大堆相反。

在堆排序中，通常使用的是最大堆，最小堆通常在构造优先队列的时候使用。

堆可以被看成是一颗树，节点在堆中的高度定义为从本节点到叶子的最长简单下降路径上边的数目；定义堆的高度为树根的高度。因为具有n个元素的堆是基于一棵完全二叉树的，因而其高度为O(lgn)。堆结构上的一些操作的运行时间至多与树的高度成正比，为O(lgn).

*** 保持堆的性质
MAX-HEAPIFY是对堆进行操作的重要子程序，其输入为一个数组A和下标i。MAX-HEAPIFY让A[i]在最大堆中下降，使以i为根的子树成为最大堆。

- 算法的过程
  在算法的每一步里，从元素A[i]，A[Left(i)]和A[Right(i)]中找出最大的元素，并将其下标保存在largest中。如果A[i]是最大的，则以i为根的子树已经是最大堆，程序结束。否则，则交换A[i]和A[largest]，从而使i及其子女满足堆性质。下标为largest的节点在交换后的值是A[i]，以该节点为根的子树又有可能违反最大堆的性质，因而要对该子树递归调用MAX-HEAPIFY。

- MAX-HEAPIFY作用于一个高度为h的节点所需要的运行时间为O(h)。
*** 建堆
我们可以自底向上地用MAX-HEAPIFY来将一个数组A[1..n]变成一个最大堆。具体的算法过程见CLRS P133-134。
*** 堆排序算法
- 时间复杂度：O(nlgn)
*** 优先级队列
- 优先级队列是一种用来维护由一组元素构成的集合S的数据结构，这一组元素中的每一个都有一个关键字key。一个最大优先级队列支持以下操作：
  - Insert(S, x): 把元素x插入到集合S
  - Maximum(S): 返回S中具有最大关键字的元素
  - Extract-Max(S): 去掉并返回S中具有最大关键字的元素
  - Increase-Key(S, x, k):  将元素x的关键字的值增加到k，这里的k的值不能小于x的原关键字的值
- 最大优先级队列的一个应用是在一台分时计算机上进行作业调度。这种队列对要执行的各作业及它们之间的相对优先关系加以记录。当一个作业完成或被中断时，用Extract-Max操作从所有等待的作业中，选择出具有最高优先级的作业。在任何时候，一个新作业都可以用Insert加入到队列中去。
** 第7章 快速排序
快速排序是一种排序算法，对包含n个数的输入数组，最坏情况运行时间为O(n^2)，但快速排序通常是用于排序的最佳实用选择，其平均期望的运行时间为O(nlgn)。
*** 快速排序的描述
- 快速排序基于分治法
- 对一个典型子数组A[p..r]进行排序的三个步骤：
  - 分解：数组A[p..r]被划分成两个（可能空）子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每个元素都小于等于A(q)，而且小于等于A[q+1..r]中的元素。下标q也在这个划分的过程中进行计算
  - 解决：通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序
  - 合并：因为两个子数组是就地排序的，将它们合并并不需要操作：整个数组A[p..r]已经排好序
*** 快速排序的随机化版本
- 在探讨快速排序的平均性态中，我们已假定输入数据的所有排列都是等可能的，但在工程中，这个架设就不会总成立。有时，我们可以向一个算法中加入随机化的成分，以便对于所有输入，它均能获得较好的平均情况性能。
- 随机取样（random sampling）
** 第8章 线性时间排序
几种时间复杂度为O(nlgn)的排序算法：归并排序、堆排序、快速排序。其中归并排序和堆排序在最坏情况下到达此上界，而快速排序在平均情况下到达此上界。

这些算法都有一些共同的性质：排序结果中，各元素的次序基于输入元素间的比较，我们把这类排序成为比较排序。

第8章介绍的三种排序算法：计数排序、基数排序和桶排序都是用非比较的方法来进行排序的。

*** 排序算法的下界
- 决策树模型
  比较排序可以被抽象地视为决策树。一棵决策树是一棵满二叉树，表示某排序算法作用于给定输入所做的所有比较，而控制结构、数据移动等都被忽略了。
- 最坏情况下界
  - 任意一个比较排序算法在最坏的情况下，都需要做𝛀(nlgn)次的比较
  - 堆排序和归并排序都是渐近最优的比较排序算法

*** 计数排序
- 在特定的条件下，时间复杂度为O(n)
- 计数排序的一个重要性质就是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的次序相同。

** 第9章 Medians and Order Statistics
* 附录：数学基础知识
** 集合等离散数学结构
*** 树
**** 自由树
- 自由树是一个连通的，无回路的无向图。
- 如果一个无向图是无回路的但可能是非连通的，称为森林。
- 自由树的一些性质
  令G=(V, E)为一个无向图。下面的表述是等价的
  1. G是自由树
  2. G中任意两个顶点由唯一一条简单路径相连
  3. G是连通的，但从E中去掉任何边后得到的图都是飞连通的
  4. G是连通的，且|E| = |V| - 1
  5. G是无回路的，且|E| = |V| - 1
  6. G是无回路的，但添加任何边到E中后得到的图包含回路
**** 有根树和有序树
- 有根树是一棵自由树，它有一个与其他点不同的节点。这个特殊的顶点称为树的根。通常称有根树的顶点为结点。
- 祖先、子孙、真祖先、真子孙的概念
**** 二叉树与位置树
- 二叉树的定义是以递归的形式给出的
- 在一棵二叉树中，如果一个节点仅有一个子女，那么它是左子女还是右子女是有关系的；在一棵有序树中，一个单独子女在左在右没有区别。
- 满二叉树：每个节点或者是叶结点，或者度数为2，不存在度数为1的节点。
- 在位置树中，节点的子女用不同的正整数标识。如果没有节点被标识成整数i，则节点的第i个子女缺失
- 一棵完全二叉树有 =2^h - 1= 个内部节点
